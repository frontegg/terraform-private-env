name: Reset Frontegg Environment

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  reset-env:
    if: contains(fromJSON('["eyaltam1971"]'), github.actor)
    env:
      AWS_REGION: us-east-1
      AWS_ASSUME_ROLE_ARN: arn:aws:iam::109940070146:role/cross-account-admin-assume-role
      EKS_CLUSTER_NAME: private-env-prod-eks

    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::109940070146:role/cross-account-admin-assume-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Kubeconfig
        run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} || true

      - name: Uninstall Frontegg Core Services
        run: |
          helm uninstall frontegg-core-services --namespace frontegg || true

      - name: Uninstall Frontegg Dashboard
        run: |
          helm uninstall frontegg-dashboard --namespace frontegg || true

      - name: Create Terraform output file for MySQL password
        run: |
          echo 'output "mysql_pass" {
            value     = random_password.mysql_password[0].result
            sensitive = true
          }' > mysql_password_output.tf
          ls -la

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ASSUME_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=frontegg-tfstate-109940070146-us-east-1" \
            -backend-config="key=tf-state/frontegg/private-env/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="dynamodb_table=frontegg-terraform-state-lock" \
            -backend-config="encrypt=true"

      - name: Terraform Apply
        run: terraform apply -auto-approve

      - name: Extract MySQL Terraform Outputs
        id: tf_mysql
        run: |
          terraform output -json mysql_output | grep '^{' > mysql_output.json
          terraform output -json mysql_pass | grep '^"' > mysql_pass.json
          echo "--- mysql_output.json content ---"
          cat mysql_output.json
          echo "---------------------------------"
          MYSQL_HOST=$(jq -r .db_instance_address mysql_output.json)
          MYSQL_USER=$(jq -r .db_instance_username mysql_output.json)
          MYSQL_PASSWORD=$(jq -r . mysql_pass.json)
          echo "Extracted MYSQL_HOST: $MYSQL_HOST"
          echo "Extracted MYSQL_USER: $MYSQL_USER"
          echo "Extracted MYSQL_PASSWORD length: ${#MYSQL_PASSWORD}"
          echo "mysql_host=$MYSQL_HOST" >> $GITHUB_OUTPUT
          echo "mysql_user=$MYSQL_USER" >> $GITHUB_OUTPUT
          echo "mysql_password=$MYSQL_PASSWORD" >> $GITHUB_OUTPUT

      - name: Extract Redis Terraform Outputs
        id: tf_redis
        run: |
          terraform output -json redis_output | grep '^{' > redis_output.json
          echo "--- redis_output.json content ---"
          cat redis_output.json
          echo "---------------------------------"
          REDIS_HOST=$(jq -r .elasticache_replication_group_primary_endpoint_address redis_output.json)
          echo "Extracted REDIS_HOST: $REDIS_HOST"
          echo "redis_host=$REDIS_HOST" >> $GITHUB_OUTPUT

      - name: Extract Kafka Terraform Outputs
        id: tf_kafka
        run: |
          terraform output -json msk_output | grep '^{' > msk_output.json
          echo "--- msk_output.json content ---"
          cat msk_output.json
          echo "-------------------------------"
          KAFKA_BOOTSTRAP=$(jq -r .bootstrap_brokers_plaintext msk_output.json)
          echo "Extracted KAFKA_BOOTSTRAP: $KAFKA_BOOTSTRAP"
          echo "kafka_bootstrap=$KAFKA_BOOTSTRAP" >> $GITHUB_OUTPUT

      - name: Configure Kubectl
        run: |
          aws eks update-kubeconfig --name private-env-prod-eks --region ${{ env.AWS_REGION }}
          kubectl get pods -n frontegg

      - name: Drop all MongoDB collections
        env:
          MONGO_URI: "mongodb://mongodb.frontegg.svc.cluster.local:27017/"
        run: |
          POD_NAME=$(kubectl get pods --namespace frontegg -l "app.kubernetes.io/name=mongodb,app.kubernetes.io/instance=mongodb,app.kubernetes.io/component=mongodb" -o jsonpath="{.items[0].metadata.name}")
          echo "Executing command on pod: $POD_NAME"

          echo 'db.getMongo().getDBNames().forEach(function(dbName) {
            if (dbName !== "admin" && dbName !== "local" && dbName !== "config") {
              db = db.getSiblingDB(dbName);
              db.getCollectionNames().forEach(function(c) {
                if (!c.startsWith("system.")) {
                  db[c].drop();
                }
              });
            }
          });' > drop_collections.js

          kubectl cp drop_collections.js "${POD_NAME}:/tmp/drop_collections.js" --namespace frontegg
          kubectl exec -n frontegg "$POD_NAME" -- mongosh "$MONGO_URI" --file /tmp/drop_collections.js

      - name: Flush all Redis keys
        env:
          REDIS_HOST: ${{ steps.tf_redis.outputs.redis_host }}
        run: |
          kubectl run redis-cli --image=redis:7.2-alpine -i --rm --restart=Never --command -- redis-cli -h "$REDIS_HOST" -p 6379 FLUSHALL

      - name: Drop MySQL databases
        env:
          MYSQL_HOST: ${{ steps.tf_mysql.outputs.mysql_host }}
          MYSQL_USER: ${{ steps.tf_mysql.outputs.mysql_user }}
          MYSQL_PASSWORD: ${{ steps.tf_mysql.outputs.mysql_password }}
        run: |
          echo "=== Databases BEFORE dropping ==="
          kubectl run mysql-cli --image=mysql:8.0 -i --rm --restart=Never -n frontegg -- \
            mysql -h "$MYSQL_HOST" -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "SHOW DATABASES;"

          echo -e "\n=== Dropping databases ==="
          kubectl run mysql-cli --image=mysql:8.0 -i --rm --restart=Never -n frontegg -- \
            mysql -h "$MYSQL_HOST" -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "
              SELECT CONCAT('Dropping database: ', SCHEMA_NAME) AS 'Operation'
              FROM information_schema.SCHEMATA 
              WHERE SCHEMA_NAME LIKE 'frontegg_%';
              
              DROP DATABASE IF EXISTS frontegg_applications;
              DROP DATABASE IF EXISTS frontegg_audits;
              DROP DATABASE IF EXISTS frontegg_backoffice;
              DROP DATABASE IF EXISTS frontegg_custom_code;
              DROP DATABASE IF EXISTS frontegg_dashboard_env_builder;
              DROP DATABASE IF EXISTS frontegg_entitlements;
              DROP DATABASE IF EXISTS frontegg_env_duplicator;
              DROP DATABASE IF EXISTS frontegg_event_retry;
              DROP DATABASE IF EXISTS frontegg_events;
              DROP DATABASE IF EXISTS frontegg_identity;
              DROP DATABASE IF EXISTS frontegg_logs_streaming;
              DROP DATABASE IF EXISTS frontegg_oauth;
              DROP DATABASE IF EXISTS frontegg_security_engines;
              DROP DATABASE IF EXISTS frontegg_subscriptions;
              DROP DATABASE IF EXISTS frontegg_team_management;
              DROP DATABASE IF EXISTS frontegg_tenants;
              DROP DATABASE IF EXISTS frontegg_vendors;
              DROP DATABASE IF EXISTS frontegg_webhooks;"

          echo -e "\n=== Databases AFTER dropping ==="
          kubectl run mysql-cli --image=mysql:8.0 -i --rm --restart=Never -n frontegg -- \
            mysql -h "$MYSQL_HOST" -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "
              SELECT 'Remaining frontegg databases:' AS 'Status';
              SELECT SCHEMA_NAME AS 'Database'
              FROM information_schema.SCHEMATA 
              WHERE SCHEMA_NAME LIKE 'frontegg_%';"

      - name: Delete all Kafka topics
        env:
          KAFKA_BOOTSTRAP: ${{ steps.tf_kafka.outputs.kafka_bootstrap }}
        run: |
          echo "=== Topics BEFORE deletion ==="
          kubectl run kafka-admin --image=bitnami/kafka:3.6.1 -i --rm --restart=Never --namespace frontegg \
            --command -- bash -c "
            kafka-topics.sh --bootstrap-server $KAFKA_BOOTSTRAP --list --exclude-internal
            "

          echo -e "\n=== Creating topic deletion script ==="
          cat << 'EOF' > delete_topics.sh
          #!/bin/bash
          set -e

          BOOTSTRAP="$1"
          MAX_RETRIES=3
          WAIT_TIME=10 # seconds between retries
          DELETE_TIMEOUT=60 # seconds to wait for topic deletion

          # Function to check topic deletion status
          check_topic_status() {
            local topic="$1"
            kafka-topics.sh --bootstrap-server "$BOOTSTRAP" --describe --topic "$topic" 2>&1 | grep -q "Topic '$topic' does not exist"
          }

          # Function to delete a single topic with retries
          delete_single_topic_with_retries() {
            local topic="$1"
            local attempt=1

            while [ $attempt -le $MAX_RETRIES ]; do
              echo "Attempt $attempt to delete topic: $topic"
              # Try to delete the topic
              if kafka-topics.sh --bootstrap-server "$BOOTSTRAP" --delete --topic "$topic" 2>/dev/null; then
                # Wait for the topic to be deleted
                echo "Waiting for topic $topic to be deleted..."
                start_time=$(date +%s)
                while ! check_topic_status "$topic"; do
                  current_time=$(date +%s)
                  if [ $((current_time - start_time)) -gt $DELETE_TIMEOUT ]; then
                    echo "Timeout waiting for topic $topic to be deleted"
                    break
                  fi
                  sleep 5
                done
                # Check if topic is deleted
                if check_topic_status "$topic"; then
                  echo "Topic $topic successfully deleted"
                  return 0
                else
                  echo "Topic $topic still exists after deletion attempt"
                fi
              else
                echo "Failed to initiate deletion for topic: $topic"
              fi
              attempt=$((attempt + 1))
              if [ $attempt -le $MAX_RETRIES ]; then
                echo "Retrying in $WAIT_TIME seconds..."
                sleep $WAIT_TIME
              fi
            done
            echo "Failed to delete topic $topic after $MAX_RETRIES attempts"
            return 1
          }

          # List all non-internal topics
          echo "Listing non-internal topics..."
          ALL_TOPICS=$(kafka-topics.sh --bootstrap-server "$BOOTSTRAP" --list --exclude-internal)

          # Remove Amazon MSK and other system/internal topics
          echo "Filtering out system/internal topics..."
          TOPICS=$(echo "$ALL_TOPICS" | grep -v -E '^(__amazon_msk_|__amazon_|__msk_|__consumer_|__transaction_|_confluent|_schema|connect\\.|kafka\\.)' || true)

          if [ -z "$TOPICS" ]; then
            echo "No application topics found to delete."
            exit 0
          fi

          echo "Found application topics to delete:"
          echo "$TOPICS"

          # Try individual deletions with retries
          echo "Starting individual topic deletions with retries..."
          failed_topics=""

          while IFS= read -r topic; do
            if [ -n "$topic" ]; then
              if ! delete_single_topic_with_retries "$topic"; then
                failed_topics="$failed_topics$topic"$'\n'
              fi
            fi
          done <<< "$TOPICS"

          # Check if any topics failed to delete
          if [ -n "$failed_topics" ]; then
            echo "The following topics failed to delete after $MAX_RETRIES attempts:"
            echo "$failed_topics"
            exit 1
          fi

          # Final verification
          echo "Performing final verification..."
          ALL_REMAINING=$(kafka-topics.sh --bootstrap-server "$BOOTSTRAP" --list --exclude-internal)
          REMAINING_TOPICS=$(echo "$ALL_REMAINING" | grep -v -E '^(__amazon_msk_|__amazon_|__msk_|__consumer_|__transaction_|_confluent|_schema|connect\\.|kafka\\.)' || true)

          if [ -n "$REMAINING_TOPICS" ]; then
            echo "Warning: Some application topics still exist:"
            echo "$REMAINING_TOPICS"
            exit 1
          else
            echo "All application topics have been deleted successfully!"
          fi
          EOF

          chmod +x delete_topics.sh

          echo -e "\n=== Executing topic deletion ==="
          kubectl run kafka-admin --image=bitnami/kafka:3.6.1 -i --rm --restart=Never --namespace frontegg \
            --command -- bash -c "
            set -e
            cd /tmp
            cat > delete_topics.sh
            chmod +x delete_topics.sh
            ./delete_topics.sh '$KAFKA_BOOTSTRAP'
            " < delete_topics.sh

          echo -e "\n=== Topics AFTER deletion ==="
          kubectl run kafka-admin --image=bitnami/kafka:3.6.1 -i --rm --restart=Never --namespace frontegg \
            --command -- bash -c "
            kafka-topics.sh --bootstrap-server $KAFKA_BOOTSTRAP --list --exclude-internal
            "
